# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'filebroswer.ui'
#
# Created by: PyQt5 UI code generator 5.15.4
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.
import os
import sys

import requests
from PyQt5 import QtCore, QtWidgets
from PyQt5.QtWidgets import QFileDialog, QMessageBox
import images_rc
from downloadDouyin import AnalysisTik


class Window(QtWidgets.QMainWindow):
    allow_download = True  # 类属性（公有）
    __allow_download = True  # 类属性（私有）

    def __init__(self):
        super(Window, self).__init__()
        self.setupUi(self)
        # 一个按钮的点击事件，响应函数为 def dircEvent(self):
        self.pushButton.clicked.connect(self.paramUrlEvent)
        self.pushButton_2.clicked.connect(self.dircEvent)
        # 点击确定事件
        self.pushButton_3.clicked.connect(self.downLoadEvent)
        # self.menu_2.clicked.connect(self.aboutPop)

    def aboutPop(self):
        ele = QMessageBox.about(self, '关于', '作者\ndream')

    def paramUrlEvent(self):
        paramUrl = self.lineEdit.text()  # 从输入框获得用户输入的文本信息，单行显示
        print("下载地址: %s" % paramUrl)
        # 回显下载地址
        self.lineEdit_2.setText(paramUrl)

    def dircEvent(self):
        directory1 = QFileDialog.getExistingDirectory(self, "选取文件夹", "./")  # 起始路径
        print("保存目录：{0}".format(directory1))
        # 回显目录
        self.lineEdit_2.setText(directory1)
        # filePath, filetype = QtWidgets.QFileDialog.getOpenFileName(self, "选取文件", "./", "*.*")
        # print(filetype)
        # print(filePath)

    def downLoadEvent(self):
        try:
            # 解析地址下载
            if not self.lineEdit.text().__contains__("https"):
                QMessageBox.warning(self, '警告', '下载地址不合法', QMessageBox.Yes | QMessageBox.No, QMessageBox.Yes)
                return
            savePath = self.lineEdit_2.text()
            print(f"savePath:{savePath}")
            if len(savePath) == 0:
                QMessageBox.warning(self, '警告', '保存目录不能为空', QMessageBox.Yes | QMessageBox.No, QMessageBox.Yes)
                return
            if not self.allow_download:
                QMessageBox.warning(self, '警告', '请等待当前任务下载完')
            # 执行下载
            QMessageBox.about(self, '提示', '正在后台下载请稍候...')
            self.allow_download = False
            # infoBox = QtGui.QMessageBox()  ##Message Box that doesn't run
            # infoBox.setIcon(QtGui.QMessageBox.Information)
            # infoBox.setText("正在后台下载请稍候！")
            # infoBox.setWindowTitle("Information")
            # infoBox.setStandardButtons(QtGui.QMessageBox.Ok)
            # infoBox.button(QtGui.QMessageBox.Ok).animateClick(3 * 1000)  # 3秒自动关闭
            # infoBox.exec_()
            self.progressBar.show()
            videoMsg = AnalysisTik().doAnalysis(self.lineEdit.text())
            print("最终视频地址：%s" % videoMsg['notWaterMarkerUrl'])
            print("最终视频标题：%s" % videoMsg['title'])
            self.doDownLoad(videoMsg['notWaterMarkerUrl'], savePath, videoMsg['title'])
            self.progressBar.reset()
            self.progressBar.hide()
            QMessageBox.about(self, '提示', '下载成功!')
        except Exception as e:
            self.allow_download = True
            print(e)
            QMessageBox.warning(self, '警告', '下载失败')
        finally:
            self.allow_download = True

    def doDownLoad(self, url: str, local_save_path: str, fileName: str) -> None:
        """
        下载视频到本地目录
        :param url: 下载地址
        :param local_save_path: 本地文件保存路径 命名方式: file +filename 注意需要指定文件名，否则报错
        :return:
        """
        try:
            headers = self.getHeader()
            # requests发送浏览器发送get请求,得到数据
            response = requests.get(url=url, headers=headers, stream=True)
            print(response)  # 输出r访问状态
            # 获取数据的二进制长度
            reponse_body_lenth = int(response.headers.get("Content-Length"))

            # 如果不存在则创建视频文件夹存放视频
            if not os.path.exists(local_save_path):
                os.mkdir(local_save_path)

            # 打印数据的长度
            # path_1为完整文件保存路径
            path_1 = (local_save_path + fileName + '.mp4')
            print("视频:%s  数据长度为:%s   保存文件：%s" % (url, reponse_body_lenth, path_1))

            if os.path.exists(path_1):
                print("视频已存在!")
                return

            # 保存抖音视频mp4格式，二进制读取
            # with open(path_1, "wb") as xh:
            with open((f"{local_save_path}\{fileName}.mp4"), "wb") as xh:
                # 先定义初始进度为0
                write_all = 0
                for chunk in response.iter_content(chunk_size=1000000):
                    write_all += xh.write(chunk)
                    # 打印下载进度
                    progress = 100 * write_all / reponse_body_lenth
                    print("下载进度：%0.2d%%" % progress)
                    # 设置进度条当前值
                    self.progressBar.setValue(progress)
                    # print(f"file:{url} download success!")
        except Exception as e:
            print(f"downLoad file error,please check whether the file path is correct!\nerror massage：{e} ")
            raise e
        print("download success!")

    def getHeader(self):
        # 请求头使用浏览器模拟的手机端请求头
        headers = {
            'user-agent': 'Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.5060.114 Mobile Safari/537.36 Edg/103.0.1264.62'
        }
        return headers

    def setupUi(self, MainWindow):
        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(800, 600)
        # 固定大小,不能放大窗口
        MainWindow.setFixedSize(800, 600)
        self.centralwidget = QtWidgets.QWidget(MainWindow)
        self.centralwidget.setObjectName("centralwidget")
        self.frame = QtWidgets.QFrame(self.centralwidget)
        self.frame.setGeometry(QtCore.QRect(70, 30, 661, 491))
        self.frame.setFrameShape(QtWidgets.QFrame.StyledPanel)
        self.frame.setFrameShadow(QtWidgets.QFrame.Raised)
        self.frame.setObjectName("frame")
        self.lineEdit = QtWidgets.QLineEdit(self.frame)
        self.lineEdit.setGeometry(QtCore.QRect(140, 140, 511, 21))
        self.lineEdit.setObjectName("lineEdit")
        self.pushButton = QtWidgets.QPushButton(self.frame)
        self.pushButton.setGeometry(QtCore.QRect(10, 140, 88, 23))
        self.pushButton.setObjectName("pushButton")
        self.pushButton_2 = QtWidgets.QPushButton(self.frame)
        self.pushButton_2.setGeometry(QtCore.QRect(10, 250, 88, 23))
        self.pushButton_2.setObjectName("pushButton_2")
        # self.pushButton_2.setStyleSheet("color: white ;  background-image: url(images/haizei.jpeg)")

        self.lineEdit_2 = QtWidgets.QLineEdit(self.frame)
        self.lineEdit_2.setGeometry(QtCore.QRect(140, 250, 511, 21))
        self.lineEdit_2.setObjectName("lineEdit_2")
        self.pushButton_3 = QtWidgets.QPushButton(self.frame)
        self.pushButton_3.setGeometry(QtCore.QRect(250, 340, 88, 23))
        self.pushButton_3.setObjectName("pushButton_3")

        # 载入进度条控件
        self.progressBar = QtWidgets.QProgressBar(self.frame)
        self.progressBar.setGeometry(QtCore.QRect(250, 390, 118, 23))
        # self.progressBar.setProperty("value", 0)
        # 进度条
        self.progressBar.setValue(0)  # 设置进度条的最小值
        self.progressBar.setMaximum(100)  # 设置进度条的最大值
        self.progressBar.setObjectName("progressBar")
        # 初始化先隐藏
        self.progressBar.hide()

        MainWindow.setCentralWidget(self.centralwidget)
        self.menubar = QtWidgets.QMenuBar(MainWindow)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 800, 23))
        self.menubar.setObjectName("menubar")
        self.menu = QtWidgets.QMenu(self.menubar)
        self.menu.setObjectName("menu")
        self.menu_2 = QtWidgets.QMenu(self.menubar)
        self.menu_2.setObjectName("menu_2")
        MainWindow.setMenuBar(self.menubar)
        self.statusbar = QtWidgets.QStatusBar(MainWindow)
        self.statusbar.setObjectName("statusbar")
        MainWindow.setStatusBar(self.statusbar)
        self.menu.addSeparator()
        self.menu.addSeparator()
        self.menu_2.addSeparator()
        self.menubar.addAction(self.menu.menuAction())
        self.menubar.addAction(self.menu_2.menuAction())

        self.retranslateUi(MainWindow)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)

    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "抖音视频链接解析下载神器-v1.0.0"))
        MainWindow.setWindowOpacity(0.995)
        # MainWindow.setStyleSheet('#Form{background-color:#ffffff;}')
        # MainWindow.setStyleSheet("color: white ;  background-image: url(images/sky-city.png)")
        # MainWindow.setStyleSheet("color: white ;  background-image: url(images/haizei.jpeg)")
        MainWindow.setStyleSheet("color: white ;  background-image: url(:/haizei.jpeg)")
        # MainWindow.setStyleSheet('#Form{border-image:url(D:/chrome-download/haizei.jpeg);}')  # 设置背景图

        # 设置背景图片
        # palette = QPalette()
        # palette.setColor(QPalette.Background, Qt.QColor.red())  # 设置窗口背景颜色
        # palette.brush(MainWindow.backgroundRole(), QBrush(QPixmap(r"D:\chrome-download\haizei.jpeg")))
        # self.setPalette(palette)

        self.pushButton.setText(_translate("MainWindow", "下载地址"))
        self.pushButton_2.setText(_translate("MainWindow", "保存目录"))
        self.pushButton_3.setText(_translate("MainWindow", "确定"))
        self.menu.setTitle(_translate("MainWindow", "文件"))
        self.menu_2.setTitle(_translate("MainWindow", "关于"))


if __name__ == '__main__':
    app = QtWidgets.QApplication(sys.argv)
    mywindow = Window()
    mywindow.show()
    sys.exit(app.exec_())
